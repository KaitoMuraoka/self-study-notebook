\RequirePackage{plautopatch}
\RequirePackage[l2tabu, orthodox]{nag}

\documentclass[platex,dvipdfmx]{jlreq}			% for platex
% \documentclass[uplatex,dvipdfmx]{jlreq}		% for uplatex
\usepackage{graphicx}
\usepackage{bxtexlogo}
\usepackage{braket}  % ブラケット表示
\usepackage{amsmath}

\title{量子位相推定}

\author{9BSP1118 村岡海人}
\date{\today}
\begin{document}
\maketitle
\section{概要}
量子位相推定アルゴリズムは、ユニタリ演算子$U$とその固有ベクトルの１つ$\ket{\psi}$が与えられた時、その固有値を求めるアルゴリズムである。このアルゴリズムは数多くの量子アルゴリズムの基礎として使われており、量子アルゴリズムの中で最も重要なものの１つである。
\subsection{アダマールテストの改良}
ユニタリ演算$U$の固有値$e^{i \lambda}$を求める問題を考える。アダマールテストでは、固有値の位相$\lambda$はテストの測定結果の確率分布に反映され、測定結果を沢山サンプルすることで$\lambda$を推定していた。これを工夫することにより、測定結果から位相の情報を直接取り出す。

アダマールテストを始める前に %FIX:この表記は変えた方がいいかも
準備として、$\lambda/2\pi$を2進数に変換すると、
\begin{eqnarray*}
    \frac{\lambda}{2\pi} = \frac{j_1}{2^1} + \frac{j_2}{2^2} + \cdots + \frac{j_k}{2^k} + \cdots
\end{eqnarray*}
となる。$j_k$は$0$または$1$の値をとる古典ビットである。$\lambda$は$e^{i\lambda}$% 未満である
の形のみ出てくるので、$0 \leq \lambda \leq 2\pi$として一般性を失わない。この2進数展開を少数の表記にならって書くと、
\begin{eqnarray*}
    \frac{\lambda}{2\pi} = \frac{j_1}{2^1} + \frac{j_2}{2^2} + \cdots + \frac{j_k}{2^k} + \cdots \\
    \Leftrightarrow \lambda = (2\pi)0.j_1j_2 \cdots j_k \cdots
\end{eqnarray*}
 以下、簡単のため、$\lambda / 2\pi$は小数点以下$n$桁で書けるものとする。% ここが議論が必要
 \begin{eqnarray*}
    \lambda = (2\pi)0.j_1j_2j_3 \cdots j_n
 \end{eqnarray*}

 % ここから本番
 アダマールテストでは制御ユニタリ演算として$\Lambda (U)$を用いたが、今回はそれを変えた$\Lambda (U^{2^k})$とする。ユニタリ演算$U$の固有状態$\ket{\psi}$とすると、制御ユニタリ演算を作用させた後の状態は、
 \begin{eqnarray*}
    \frac{1}{\sqrt{2}} \left( \ket{0} + e^{i 2^k \lambda} \ket{1} \right) \otimes \ket{\psi}
 \end{eqnarray*}
 上記の2進数展開を使うと、
 \begin{eqnarray*}
    2^k \lambda = 2^k \cdot (2\pi)0.j_1j_2j_3 \cdots j_r = (2\pi)j_1j_2 \cdots j_k.j_{k+1} \cdots j_n
 \end{eqnarray*}
 $e^{i(2\pi)j_1 \cdots j_k} = 1$なので、
 \begin{eqnarray}
    \frac{1}{\sqrt{2}}\left( \ket{0} + e^{i(2\pi)0.j_{k+1 \cdots j_n}}\ket{1} \right) \otimes \ket{\psi}
 \end{eqnarray}
 となる。

 次に、固有値の位相を1桁ずつ確定した量子ビットの状態として取り出す。$k=n-1$のとき、
 \begin{eqnarray*}
    \frac{1}{\sqrt{2}}\left( \ket{0} + e^{i (2\pi) 0.j_n}\ket{1} \right)
 \end{eqnarray*}
 となり($\ket{\psi}$は省略)、アダマールゲートを作用させると、
 \begin{eqnarray*}
    \frac{1}{\sqrt{2}}\left( \ket{0} + e^{i (2\pi) 0.j_n}\ket{1} \right) \rightarrow \ket{j_n}
 \end{eqnarray*}
 となる。$\lambda$の2進小数表示の$n$番目のビット$j_n = \pm 1$に対応した状態に変換できる。この状態を測定すれば、$100\%$の確率で$j_n$が観測されるので、１回の測定で$\lambda$の$n$桁目を決定することができる。
 次に$k = n -2$の時を考えると、状態は
 \begin{eqnarray*}
    \frac{1}{\sqrt{2}}\left( \ket{0} + e^{i (2\pi) 0.j_{n-1}j_n} \ket{1} \right)
 \end{eqnarray*}
 である。$j_n$は先ほど調べてあるので、$j_n = 0$の時は何もせず、$j_n = 1$の時は一般位相ゲート、
 \begin{eqnarray*}
    R_l ^{\dag} = 
    \begin{pmatrix}
        1 & 0 \\
        0 & e^{-i \frac{2\pi}{2^l}}
    \end{pmatrix}
 \end{eqnarray*}
 より、$R^{\dag} _2$を作用させれば、
 \begin{eqnarray*}
    \frac{1}{\sqrt{2}}\left( \ket{0} + e^{i(2\pi)0.j_{n-1}j_n}\ket{1} \right) \rightarrow \frac{1}{\sqrt{2}}\left( \ket{0} + e^{i(2\pi)0.j_{n-1}}\ket{1} \right)
 \end{eqnarray*}
 と変換できる。
 そして、アダマールゲートを作用させれば、
 \begin{eqnarray*}
    \frac{1}{\sqrt{2}}\left( \ket{0} + e^{i(2\pi) 0.j_{n-1}} \ket{1} \right) \rightarrow \ket{j_{n-1}}
 \end{eqnarray*}
 となるから、$j_{n-1}$もこの状態を１回測定するだけで決定できる。

 以降、同様に$k = n-3, n-4, \cdots , 0$ とすれば下の方の桁から$j_{k+1}$を決定していくことができる。

 このようにして、アダマールテストを変形することにより、固有値の位相を1桁ずつ確定した量子ビットの状態として取り出すことができる。この手続きを量子回路で一度に行うのが量子位相推定アルゴリズムである。

 \subsection{量子位相推定アルゴリズムの概要}
 量子位相推定アルゴリズムは、上記のアルゴリズムの測定側の量子ビットを拡張し、量子フーリエ変換を組み合わせたものである。

 $U$を量子回路として構成できる一般的なユニタリ行列とする。$U$の固有ベクトルを$\ket{eigen_l}$とし、対応する固有値を$e^{i\lambda_l}$とする。ある一般的な量子状態$\ket{\psi}$が与えられたとする。これは必ず固有ベクトルで展開できるので、　
 \begin{eqnarray*}
    \ket{\psi} = \sum_l c_l \ket{eigen_l}
 \end{eqnarray*} %?????
 となる。具体的に係数$c_l$がどのような値になるかはまだわからない。このとき、量子位相推定アルゴリズムは、$n$個の補助量子ビットを用いて、入力状態
 \begin{eqnarray*}
    \ket{00\cdots 0}\ket{\psi}
 \end{eqnarray*}
  を、
  \begin{eqnarray*}
    \sum_l c_l \ket{\lambda_l}\ket{eigen_l}
  \end{eqnarray*}
  へと変換するアルゴリズムのことである。ここで、$\ket{\lambda_l}$は固有値の位相$\lambda_l$の2進小数表示$\lambda_l = (2\pi) 0.j^{(l)}_1 \cdots j^{(l)} _n$に対応する量子状態$\ket{j^{(l)}_1 \cdots j^{(l)} _n}$である。

つまり、量子位相推定アルゴリズムは、$\ket{\psi}$の重ね合わせの中にあるそれぞれの固有ベクトルに対応した固有値を$n$個の補助量子ビットへと取り出すアルゴリズムになっている。この状態に対して補助量子ビットの測定をすると、確率、
\begin{eqnarray*}
    p_l = |c_l|^2
\end{eqnarray*}
で、どれか１つの固有ベクトル$\ket{eigen_l}$とその固有値$\lambda_l$が乱拓される。

このアルゴリズムは、素因数分解や量子化学アルゴリズムなど、多くのアルゴリズムのサブルーチンとして利用されており、量子コンピュータが従来のコンピュータよりも指数的に高速に解を得られると期待される最も重要な例である。

\section{量子位相推定アルゴリズムの回路}
以下、量子状態$\ket{\psi}$を固有状態$\ket{eigen}$とその固有値$\lambda$に限定する。
% 入力状態が固有状態の重ね合わせの場合でも全く同じ議論が使える？ので、一般性は失われていない
アダマールテストでは１つしか測定用の量子ビットを使わなかったが、量子位相推定では、測定用の補助量子ビットとして$n$個の量子ビットを確保する。量子位相推定を行う量子回路は図\ref{fig: Q}である。
\begin{figure}[htbp]
    \begin{center}
        \includegraphics[width = 150mm]{figures/Q.png}
        \caption{量子位相推定の量子回路}
        \label{fig: Q}
    \end{center}
\end{figure}

まず初めに、$\ket{0}$に初期化された$n$個の量子ビットのそれぞれに、アダマールテストと同様にアダマールゲートと制御ユニタリー演算を作用させる。ただし、$k$番目($k = 1, \cdots , n$)の補助量子ビットには制御$U^{2^{k-1}}$演算をすることにする。$U \ket{eigen} = e^{i2\pi \lambda}\ket{eigen}$だから、$k$番目の補助量子ビットには$e^{i \lambda 2^{k}}$の位相が獲得されるので、%位相キックバック
\begin{eqnarray*}
    \left( \frac{\ket{0}+e^{i(2\pi)0.j_1\cdots j_n}\ket{1}}{\sqrt{2}} \right) \otimes \left( \frac{\ket{0}+e^{i(2\pi)0.j_2\cdots j_n}\ket{1}}{\sqrt{2}} \right) \otimes \cdots \otimes \left( \frac{\ket{0}+e^{i(2\pi)0.j_n}\ket{1}}{\sqrt{2}} \right) \otimes \ket{eigen}
\end{eqnarray*}
という状態になる。つまり、固有値の位相を2進少数表示で1ビットずつシフトしたものが各補助量子ビットの位相に格納されることになる。

次に、$n$個の補助量子ビットの状態は、量子フーリエ変換の結果の式と同じ形をしている。よって、逆量子フーリエ変換(図の$QFT^{\dag}$)をこれらの補助量子ビットに作用させると、
\begin{eqnarray*}
    \left( \frac{\ket{0} + e^{i(2\pi)0.j_1\cdots j_n}\ket{1}}{\sqrt{2}} \right) \otimes \left( \frac{\ket{0} + e^{i(2\pi)0.j_2\cdots j_n}\ket{1}}{\sqrt{2}} \right) \otimes \cdots \otimes \left( \frac{\ket{0} + e^{i(2\pi)0.j_n}\ket{1}}{\sqrt{2}} \right) \otimes \ket{eigen} \rightarrow \ket{j_1 \cdots j_n}
\end{eqnarray*}
となる。よって、この段階で補助量子ビットの測定を行えば、$100\%$の確率で$j_1,j_2, \cdots, j_n$を得ることができ、$U$の固有値の位相$\lambda$が求められる。

まとめると、測定用の各量子ビットを制御ビットとする制御$U^{2^k}$演算を行い、固有値の位相の情報を補助量子ビットに移した後、逆フーリエ変換で位相の値を取り出すのが、量子位相推定アルゴリズムである。

\subsection{hoge}
制御ユニタリー演算を用いて各補助量子ビットの位相の少数第1位にのみビット$j_k$が出てくるようにし、アダマールゲートを作用させて$\ket{j_n}$が得られるようにしている。

$\ket{j_n}$は、$n$番目の補助量子ビットである。

補助量子ビットを計算基底で測定すれば、$j_1, \cdots, j_n$が得られる。
\end{document}