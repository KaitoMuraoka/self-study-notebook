\RequirePackage{plautopatch}
\RequirePackage[l2tabu, orthodox]{nag}

\documentclass[platex,dvipdfmx]{jlreq}			% for platex
% \documentclass[uplatex,dvipdfmx]{jlreq}		% for uplatex
\usepackage{graphicx}
\usepackage{bxtexlogo}
\usepackage{forloop} %繰り返し処理
\usepackage{braket} %ブラケット

\title{量子位相推定}

\author{9BSP1118 村岡海人}
\date{\today}
\begin{document}
\maketitle
\section{概要}
量子位相推定アルゴリズムは、アダマールテストの測定側の量子ビットを拡張し、量子フーリエ変換を組み合わせたものである。

アダマールテストでは、固有値の位相$\lambda$は測定結果の確率分布に反映されていた。そのため、測定結果をたくさんサンプルし、$\lambda$を推定する必要があった。
これを少し工夫することにより、測定結果から位相の情報を直接的に取り出すことができる。それが量子位相推定である。

この量子アルゴリズムは、数多くの量子アルゴリズムの基礎として使われており、量子アルゴリズムの中で最も重要なものの１つである。

\subsection{はじめに}
まず初めに、$\lambda / 2\pi$を2進数に展開する。
% $\lambda$を$n$桁まで求めたいとすると、
\begin{eqnarray}
    \frac{\lambda}{2\pi} = \frac{j_1}{2^1} + \frac{j_2}{2^2} + \cdots + \frac{j_k}{2^k} + \cdots
\end{eqnarray}
$j_k$は$0$または$1$をとる古典ビットである。$\lambda$は$e^{i\lambda}$の形のみで出てくるので、$0 \leq \lambda < 2\pi$ として一般性を失わない。この2進数を、通常の小数の表記にならって、
\begin{eqnarray}
    \lambda = (2\pi) 0.j_1j_2\cdots j_k \cdots \label{eq: binary digits}
\end{eqnarray}
と書ける。

% アダマールテストでは制御ユニタリ演算として$\Lambda (U)$を用いたが、今回はそれを変えた$\Lambda (U^{2^{k-1}})$とする。ユニタリ演算$U$の固有ベクトル$\ket{\psi}$とすると、制御ユニタリ演算を作用させた後の状態は、
% \begin{eqnarray}
%     \frac{1}{\sqrt{2}} \left( \ket{0} + e^{i 2^{k-1} \lambda} \ket{1} \right) \otimes \ket{\psi}
%  \end{eqnarray}
%  となる。2進展開を使うと、
%  \begin{eqnarray}
%     2^{k-1} \lambda = 2^{k-1} 0. j_1 j_2 \cdots j_r = (2\pi) j_1 j_2 \cdots j_k . j_{k+1}\cdots j_n
%  \end{eqnarray}
%  $e^{i(2\pi)j_1\cdots j_k} = 1$より、
%  \begin{eqnarray}
%     \frac{1}{\sqrt{2}}\left( \ket{0} + e^{i(2\pi)0.j_{k+1}\cdots j_n}\ket{1} \right) \otimes \ket{\psi}
%  \end{eqnarray}
% となる。

\subsection{位相推定アルゴリズムの流れ}

量子位相推定は以下のような流れで行う。初期化された$n$個のqビットと入力状態$\ket{\psi}$を用いてユニタリー演算$U$の固有値の位相$\lambda$を求める。
\begin{enumerate}
    \item $\ket{0}$に初期化された$n$個の補助量子ビットのそれぞれに、アダマールテストと同様、アダマールゲートを作用させる。
    \item 再度、$n$個の量子ビットのそれぞれに、制御ユニタリー演算を作用させる。ただし、$k$番目($k = 1, \cdots , n$)の補助量子ビットには制御$U^{2^{k-1}}$演算をする。
    \item $n$個の補助量子ビットに逆フーリエ変換(図\ref{fig:PEA}の$QFT^{\dagger}$)を作用させる。
    \item 最後に、補助量子ビットの測定を行えば、$100\%$の確率で$j_1, j_2\cdots ,j_n$が得られ、$U$の固有値の位相$\lambda$が求められる。
\end{enumerate}
上記のことを量子回路で表したのが図\ref{fig:PEA}である。
\begin{figure}
    \begin{center}
    \includegraphics[width = 150mm]{figures/PEA.png}
    \caption{量子位相推定の量子回路}
    \label{fig:PEA}
    \end{center}
\end{figure}

\section{量子位相推定}
\subsection{入力が固有ベクトルの場合}
入力が固有ベクトル$\ket{\psi}$である場合を考える。
また、ここでは位相$\lambda$が$n$桁まで2進数展開できる特殊な$\lambda$であるとする。すると、式（\ref{eq: binary digits}）より、位相$\lambda$の2進数展開は、
\begin{eqnarray}
    \lambda = (2\pi)0.j_1 j_2 \cdots j_n
\end{eqnarray}
となる。

まず初めに、$n$個の$\ket{0}$に初期化された補助量子ビットのそれぞれに、アダマールゲートと制御ユニタリー演算$\Lambda (U^{2^{k-1}})$を作用させる。$U\ket{\psi} = e^{i2\pi \lambda} \ket{\psi}$なので、$k$番目の補助量子ビットには$e^{i 2^{k-1} \lambda}$の位相が獲得される。

$k = 1$の場合、アダマールテストと同様に、
\begin{eqnarray}
    \frac{1}{\sqrt{2}}\left( \ket{0} + e^{i(2\pi)0.j_{1}j_{2}\cdots j_n}\ket{1} \right)
\end{eqnarray}
となり、$k = 2$の場合は、
\begin{eqnarray}
    \frac{1}{\sqrt{2}}\left( \ket{0} + e^{i(2\pi)2^1 \cdot 0.j_{1}j_{2}\cdots j_n}\ket{1} \right) \\
    = \frac{1}{\sqrt{2}}\left( \ket{0} + e^{i(2\pi)j_1.j_{2}j_{3}\cdots j_n}\ket{1} \right)\\
    = \frac{1}{\sqrt{2}}\left( \ket{0} + e^{i(2\pi)0.j_{2}j_{3}\cdots j_n}\ket{1} \right) \label{eq: 8}
\end{eqnarray}
となる。これを$n$回繰り返して、
\begin{eqnarray}
    \left( \frac{\ket{0} + e^{i(2\pi) 0. j_1 \cdots j_n} \ket{1}}{\sqrt{2}} \right) \otimes \left( \frac{\ket{0} + e^{i(2\pi) 0. j_2 \cdots j_n} \ket{1}}{\sqrt{2}} \right) \otimes \cdots \otimes \left( \frac{\ket{0} + e^{i(2\pi) 0.j_n} \ket{1}}{\sqrt{2}} \right) \otimes \ket{\psi}
    \label{eq:9}
\end{eqnarray}
という状態が得られる。つまり、固有値の位相を2進小数表示で1ビットずつシフトしたのもが各補助量子ビットの位相に格納される。

式(\ref{eq:9})の形は、量子フーリエ変換の結果の式と同じ形をしている。そのため、次は逆量子フーリエ変換($QFT^{\dagger}$)を補助量子ビットに作用させると、
\begin{eqnarray}
    \left( \frac{\ket{0} + e^{i(2\pi) 0. j_1 \cdots j_n} \ket{1}}{\sqrt{2}} \right) \otimes \left( \frac{\ket{0} + e^{i(2\pi) 0. j_2 \cdots j_n} \ket{1}}{\sqrt{2}} \right) \otimes \cdots \otimes \left( \frac{\ket{0} + e^{i(2\pi) 0.j_n} \ket{1}}{\sqrt{2}} \right) \rightarrow \ket{j_1 \cdots j_n}
\end{eqnarray}
となる。

この段階で補助量子ビットの測定を行えば、$100\%$の確率で、$j_1, j_2, \cdots , j_n$が得られ、$U$の固有値の位相$\lambda$が求められる。

% 測定を除いた回路全体を位相推定のためのユニタリー演算$W$とすると、
% \begin{eqnarray}
%     W\ket{0 \cdots 0}\ket{\psi} = \ket{j_1 \cdots j_n}\ket{\psi}
%     \label{eq: W}
% \end{eqnarray}
% となる$W$を構成できた。

まとめると、位相推定アルゴリズムによって、対応する固有ベクトル$\ket{\psi}$で与えられるユニタリーオペレータ$U$の固有値の位相$\lambda$を推定できる。この手続きの核心を成す重要な点は次の変換を実行する逆量子フーリエ変換にある。式(\ref{eq: 8})より、
\begin{eqnarray}
    \left( \frac{\ket{0} + e^{i(2\pi) 0. j_1 \cdots j_n} \ket{1}}{\sqrt{2}} \right) \otimes \cdots \otimes \left( \frac{\ket{0} + e^{i(2\pi) 0.j_n} \ket{1}}{\sqrt{2}} \right) = \frac{1}{2^{n/2}} \sum_{k = 0} ^{2^n - 1} e^{2\pi i j k}\ket{k}
\end{eqnarray}
とすると、
\begin{eqnarray}
    \frac{1}{2^{n/2}} \sum_{k = 0} ^{2^n - 1} e^{2\pi i j k}\ket{k}\ket{\psi} \rightarrow \ket{\tilde{j}}\ket{\psi}
\end{eqnarray}
ここで、$j = 0.j_1 j_2 \cdots j_n$ 、
$\ket{\tilde{\lambda}}$は測定さえれたとき$\lambda$の良い測定量を与える状態を表す。



\subsection{入力が固有ベクトルではない場合}
先ほどは、入力が固有ベクトルである場合を考えた。そのため、次は一般的な量子状態$\ket{\psi}$が与えられた場合を考える。$U$の固有ベクトル$\ket{eigen_l}$とし、対応する固有値を$e^{i \lambda_l}$とする。ある一般的な量子状態$\ket{\psi}$が与えられた場合、これは必ず固有ベクトルで展開することができるので、
\begin{eqnarray}
    \ket{\psi} = \sum_l c_l \ket{eigen_l}
\end{eqnarray}
となる。$c_l$は複素数の集合である。
%c_lは展開係数？

これを用いて、式(\ref{eq: W})より、$n$個の補助量子ビットを用いて、
\begin{eqnarray}
    W \ket{0 \cdots 0} \ket{\psi} = W \ket{0 \cdots 0} \left( \sum_l c_l \ket{eigen_l} \right) = \sum_l c_l \ket{\lambda_l} \ket{eigen_l}
\end{eqnarray}
となる。ここで、$\ket{\lambda_l}$は固有値の位相$\lambda_l$の2進小数表示$\lambda_l = (2\pi)0.j^{(l)} _1 \cdots j^{(l)} _n$に対応する量子状態$\ket{j^{(l)} _1 \cdots j^{(l)} _n}$である。

つまり、位相推定アルゴリズムは、$\ket{\psi}$の重ね合わせの中にあるそれぞれの固有ベクトルに対応した固有値を$n$個の補助量子ビットへと取り出すアルゴリズムとなっている。

この状態に対し、補助量子ビットの測定をすると、確率
\begin{eqnarray}
    p_l = |c_l|^2
\end{eqnarray}
で、どれか１つの固有ベクトル$\ket{eigen_l}$と固有値$\lambda_l$がランダムで決まり、最終的に$j^{(l)} _1 \cdots j^{(l)} _n$と$\ket{eigen_l}$が出力される。


\end{document}